<!-- Довольно простенькая задача, однако в условиях и требованиях не говорилось 
о написании даже единой строчки кода, так что объяснюсь в виде текста.

В данном примере, насколько я вижу, используется отношение many-to-many в реляционной БД.
(Об этом говорит таблица линк, которая имеет в себе указатель и на таблицу info, и на таблицу data.)
Следовательно, одни данные зависят от других, что говорит нам об обязательном использовании функционала,
уже встроенного в MySQL, а именно, первичного и внешнего ключей. Я так полагаю, на этом и заключался ваш 
вопрос в оптимизации таблиц =).

Следовательно, чтобы довольствоваться всем этим добром в прооцессе разработки,
нам необходимо будет изменить структуру таблиц, но совсем незначительно.
Единственное, что бы я добавил в существующий SQL-код, это как раз таки сами
Primary и Foreign key, чтобы позже, как уже описывалось в задании, оптимизировать
запросы посредством использования JOIN'oв.  К слову, эти самые join-ы так же 
позволят нам гибко изменять запросы под ваши нужды (outer inner left right и тд).

Изменённый SQL-код:


CREATE TABLE `info` (
        `id` int(11) NOT NULL auto_increment,
       `name` varchar(255) default NULL,
        `desc` text default NULL,
        PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=cp1251;

CREATE TABLE `data` (
        `id` int(11) NOT NULL auto_increment,
        `date` date default NULL,
        `value` INT(11) default NULL,
        PRIMARY KEY (`id`)
) ENGINE=MyISAM DEFAULT CHARSET=cp1251;

CREATE TABLE `link` (
        `data_id` int(11) NOT NULL,
        `info_id` int(11) NOT NULL,
        FOREIGN KEY (data_id) REFERENCES info(id),  // Обратите внимание на объявление внешнего ключа
        FOREIGN KEY (info_id) REFERENCES data(id)  // И тут тоже =)
) ENGINE=MyISAM DEFAULT CHARSET=cp1251;

Таким образом, немного поменяв структуру таблицы link, мы можем пользоваться join-функционалом,
а именно:

SELECT
  inf.name,
  inf.desc
from
  info inf
  INNER JOIN link l on inf.id = l.info_id
  INNER JOIN data dat on dat.id = l.data_id

И это лишь один из немногих примеров. Просто джоины на мой (сугубо личный)
взгляд будут работать быстрее чем ваш первоначальный запрос. НО ЭТО ТОЛЬКО В НЕКОТОРЫХ СЛУЧАЯХ.

На мой взгляд, в конкретно этом примере, в принципе, оптимизировать больше и нечего,
но если всё-же есть что-то что я упустил: пожалуйста, уведомите. Будет интересно пополнить
копилку знаний.

-->